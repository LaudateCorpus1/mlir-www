<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">15.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AllocationHoistingBarrierOnly.html">AllocationHoistingBarrierOnly</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1bufferization_1_1AllocationHoistingBarrierOnly.html" title="AllocationHoistingBarrierOnly is an external implementation of BufferizableOpInterface for ops that a...">AllocationHoistingBarrierOnly</a> is an external implementation of BufferizableOpInterface for ops that are (not yet) bufferizable, but are known to be allocation hoisting barriers.  <a href="structmlir_1_1bufferization_1_1AllocationHoistingBarrierOnly.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AlwaysCopyBufferizationState.html">AlwaysCopyBufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This a "no analysis, always copy" <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html" title="BufferizationState provides a variety of helper functions for dealing with tensor values and memref b...">BufferizationState</a>.  <a href="classmlir_1_1bufferization_1_1AlwaysCopyBufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1AnalysisBufferizationOptions.html">AnalysisBufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for analysis-enabled bufferization.  <a href="structmlir_1_1bufferization_1_1AnalysisBufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisBufferizationState.html">AnalysisBufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for analysis-enabled bufferization.  <a href="classmlir_1_1bufferization_1_1AnalysisBufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html">BufferizationAliasInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html" title="The BufferizationAliasInfo class maintains a list of buffer aliases and equivalence classes to suppor...">BufferizationAliasInfo</a> class maintains a list of buffer aliases and equivalence classes to support bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for ComprehensiveBufferize.  <a href="structmlir_1_1bufferization_1_1BufferizationOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html" title="BufferizationState provides a variety of helper functions for dealing with tensor values and memref b...">BufferizationState</a> provides a variety of helper functions for dealing with tensor values and memref buffers.  <a href="classmlir_1_1bufferization_1_1BufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper type converter class that automatically populates the relevant materializations and type conversions for bufferization.  <a href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html">BufferPlacementAllocs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple analysis that detects allocation operations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementAllocs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html">BufferPlacementTransformationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all BufferPlacement transformations.  <a href="classmlir_1_1bufferization_1_1BufferPlacementTransformationBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1bufferization_1_1DialectBufferizationState.html">DialectBufferizationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialect-specific bufferization state.  <a href="structmlir_1_1bufferization_1_1DialectBufferizationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9143a6cd46c797fef5768cfff4b64ac2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a9143a6cd46c797fef5768cfff4b64ac2">PostAnalysisStepFn</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html">BufferizationAliasInfo</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:a9143a6cd46c797fef5768cfff4b64ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">PostAnalysisStepFns can be registered with <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html" title="Options for ComprehensiveBufferize. ">BufferizationOptions</a></code> and are executed after the analysis, but before bufferization.  <a href="#a9143a6cd46c797fef5768cfff4b64ac2">More...</a><br /></td></tr>
<tr class="separator:a9143a6cd46c797fef5768cfff4b64ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69770dbd42d4a1a08c95e6824e30db0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa69770dbd42d4a1a08c95e6824e30db0">PostAnalysisStepList</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir_1_1bufferization.html#a9143a6cd46c797fef5768cfff4b64ac2">PostAnalysisStepFn</a> &gt;</td></tr>
<tr class="separator:aa69770dbd42d4a1a08c95e6824e30db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">BufferRelation</a> { <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754">BufferRelation::None</a>, 
<a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605">BufferRelation::Equivalent</a>
 }<tr class="memdesc:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify fine-grain relationship between buffers to enable more analysis.  <a href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:afbf6d54f9e3c10b9003b66b6224b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa24e592182e0b88ede8e85dbc3dcac5e">isFunctionArgument</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a> of a FuncOp.  <a href="#aa24e592182e0b88ede8e85dbc3dcac5e">More...</a><br /></td></tr>
<tr class="separator:aa24e592182e0b88ede8e85dbc3dcac5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05561ae5b9cceea1c45832340484ad6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a05561ae5b9cceea1c45832340484ad6b">replaceOpWithBufferizedValues</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a05561ae5b9cceea1c45832340484ad6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with replacement values.  <a href="#a05561ae5b9cceea1c45832340484ad6b">More...</a><br /></td></tr>
<tr class="separator:a05561ae5b9cceea1c45832340484ad6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplParams" colspan="2">template&lt;typename OpTy , typename... Args&gt; </td></tr>
<tr class="memitem:a91366abfb8d491ea5701260487518959"><td class="memTemplItemLeft" align="right" valign="top">OpTy&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a91366abfb8d491ea5701260487518959">replaceOpWithNewBufferizedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a91366abfb8d491ea5701260487518959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace an op with a new op.  <a href="#a91366abfb8d491ea5701260487518959">More...</a><br /></td></tr>
<tr class="separator:a91366abfb8d491ea5701260487518959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee671301347ef45d17b909d3ae286aa"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abee671301347ef45d17b909d3ae286aa">getContiguousMemRefType</a> (ShapedType shapedType, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:abee671301347ef45d17b909d3ae286aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a contiguous <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> (i.e.  <a href="#abee671301347ef45d17b909d3ae286aa">More...</a><br /></td></tr>
<tr class="separator:abee671301347ef45d17b909d3ae286aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba55edae716ab18fa6fe171c8ea804d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a7ba55edae716ab18fa6fe171c8ea804d">getMemRefType</a> (<a class="el" href="classmlir_1_1TensorType.html">TensorType</a> tensorType, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, MemRefLayoutAttrInterface layout={}, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={})</td></tr>
<tr class="memdesc:a7ba55edae716ab18fa6fe171c8ea804d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> to which the <code>tensorType</code> can be bufferized in a composable fashion.  <a href="#a7ba55edae716ab18fa6fe171c8ea804d">More...</a><br /></td></tr>
<tr class="separator:a7ba55edae716ab18fa6fe171c8ea804d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab906909c95ea6668aeec6bc2901e6936"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ab906909c95ea6668aeec6bc2901e6936">createAlloc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, MemRefType type, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynShape, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ab906909c95ea6668aeec6bc2901e6936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memref allocation with the given type and dynamic extents.  <a href="#ab906909c95ea6668aeec6bc2901e6936">More...</a><br /></td></tr>
<tr class="separator:ab906909c95ea6668aeec6bc2901e6936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6422d348bb770ae024a1571495a7587a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6422d348bb770ae024a1571495a7587a">createAlloc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, MemRefType type, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dynShape, bool deallocMemref, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a6422d348bb770ae024a1571495a7587a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memref allocation with the given type and dynamic extents.  <a href="#a6422d348bb770ae024a1571495a7587a">More...</a><br /></td></tr>
<tr class="separator:a6422d348bb770ae024a1571495a7587a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a2e4367318cf238e367aec24953cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ad45a2e4367318cf238e367aec24953cb">createAlloc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> shapedValue, bool deallocMemref, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ad45a2e4367318cf238e367aec24953cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memref allocation for the given shaped value.  <a href="#ad45a2e4367318cf238e367aec24953cb">More...</a><br /></td></tr>
<tr class="separator:ad45a2e4367318cf238e367aec24953cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e102c19d8782b9502708be05b74311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ad9e102c19d8782b9502708be05b74311">createDealloc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> allocatedBuffer, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ad9e102c19d8782b9502708be05b74311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memref deallocation.  <a href="#ad9e102c19d8782b9502708be05b74311">More...</a><br /></td></tr>
<tr class="separator:ad9e102c19d8782b9502708be05b74311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8945451b63f8606fffb80adc08ab2cbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a8945451b63f8606fffb80adc08ab2cbe">createMemCpy</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> from, <a class="el" href="classmlir_1_1Value.html">Value</a> to, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8945451b63f8606fffb80adc08ab2cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a memcpy between two given buffers.  <a href="#a8945451b63f8606fffb80adc08ab2cbe">More...</a><br /></td></tr>
<tr class="separator:a8945451b63f8606fffb80adc08ab2cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a6223871e93de2dbc611e8e54c5e4fb3b">populateBufferizeMaterializationLegality</a> (<a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target)</td></tr>
<tr class="memdesc:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>.  <a href="#a6223871e93de2dbc611e8e54c5e4fb3b">More...</a><br /></td></tr>
<tr class="separator:a6223871e93de2dbc611e8e54c5e4fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22345dcd836dbc3216a89bbd4ce26821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a22345dcd836dbc3216a89bbd4ce26821">populateEliminateBufferizeMaterializationsPatterns</a> (<a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a22345dcd836dbc3216a89bbd4ce26821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns to eliminate bufferize materializations.  <a href="#a22345dcd836dbc3216a89bbd4ce26821">More...</a><br /></td></tr>
<tr class="separator:a22345dcd836dbc3216a89bbd4ce26821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ffab001193a2ce1acc4427e25ae2cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a06ffab001193a2ce1acc4427e25ae2cc">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a06ffab001193a2ce1acc4427e25ae2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#a06ffab001193a2ce1acc4427e25ae2cc">More...</a><br /></td></tr>
<tr class="separator:a06ffab001193a2ce1acc4427e25ae2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eb90676228266b5cf038ee3565363f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac2eb90676228266b5cf038ee3565363f">bufferizeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ac2eb90676228266b5cf038ee3565363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>.  <a href="#ac2eb90676228266b5cf038ee3565363f">More...</a><br /></td></tr>
<tr class="separator:ac2eb90676228266b5cf038ee3565363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e0264f03d3674db311e3f98d9dc468"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aa1e0264f03d3674db311e3f98d9dc468">populateBufferizationPattern</a> (const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;state, <a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aa1e0264f03d3674db311e3f98d9dc468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the pattern set with a pattern that bufferizes ops that implement <code>BufferizableOpInterface</code>.  <a href="#aa1e0264f03d3674db311e3f98d9dc468">More...</a><br /></td></tr>
<tr class="separator:aa1e0264f03d3674db311e3f98d9dc468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac36c97b27b691ad7fcee01d70ca143a9">getPartialBufferizationOptions</a> ()</td></tr>
<tr class="separator:ac36c97b27b691ad7fcee01d70ca143a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aaaa111ae7f728e7e3a776a2a67a177fb">getGlobalFor</a> (arith::ConstantOp constantOp, uint64_t alignment)</td></tr>
<tr class="separator:aaaa111ae7f728e7e3a776a2a67a177fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af60e4c732407b8ec9b0bee7f33079a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a5af60e4c732407b8ec9b0bee7f33079a">analyzeOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1AnalysisBufferizationState.html">AnalysisBufferizationState</a> &amp;state)</td></tr>
<tr class="memdesc:a5af60e4c732407b8ec9b0bee7f33079a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analyze <code>op</code> and its nested ops.  <a href="#a5af60e4c732407b8ec9b0bee7f33079a">More...</a><br /></td></tr>
<tr class="separator:a5af60e4c732407b8ec9b0bee7f33079a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac312904e236e76916c7e8c1d1b989a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#ac312904e236e76916c7e8c1d1b989a1b">runOneShotBufferize</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, std::unique_ptr&lt; <a class="el" href="structmlir_1_1bufferization_1_1AnalysisBufferizationOptions.html">AnalysisBufferizationOptions</a> &gt; <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:ac312904e236e76916c7e8c1d1b989a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run One-Shot Bufferize on the given op: Analysis + Bufferization.  <a href="#ac312904e236e76916c7e8c1d1b989a1b">More...</a><br /></td></tr>
<tr class="separator:ac312904e236e76916c7e8c1d1b989a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#adbadbbffeae2eddfac65c53b2f1cadba">createBufferDeallocationPass</a> ()</td></tr>
<tr class="memdesc:adbadbbffeae2eddfac65c53b2f1cadba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the BufferDeallocation pass to free all allocated buffers.  <a href="#adbadbbffeae2eddfac65c53b2f1cadba">More...</a><br /></td></tr>
<tr class="separator:adbadbbffeae2eddfac65c53b2f1cadba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b99b019001e22f13cbb9adaf483febe"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a4b99b019001e22f13cbb9adaf483febe">createBufferHoistingPass</a> ()</td></tr>
<tr class="memdesc:a4b99b019001e22f13cbb9adaf483febe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass.  <a href="#a4b99b019001e22f13cbb9adaf483febe">More...</a><br /></td></tr>
<tr class="separator:a4b99b019001e22f13cbb9adaf483febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a94f24bfd4dabfbaa35cb099c0cc78480">createBufferLoopHoistingPass</a> ()</td></tr>
<tr class="memdesc:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that moves allocations upwards out of loops.  <a href="#a94f24bfd4dabfbaa35cb099c0cc78480">More...</a><br /></td></tr>
<tr class="separator:a94f24bfd4dabfbaa35cb099c0cc78480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbbddbfb4db56de847f081bd093a8fc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#abdbbddbfb4db56de847f081bd093a8fc">createBufferResultsToOutParamsPass</a> ()</td></tr>
<tr class="memdesc:abdbbddbfb4db56de847f081bd093a8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts memref function results to out-params.  <a href="#abdbbddbfb4db56de847f081bd093a8fc">More...</a><br /></td></tr>
<tr class="separator:abdbbddbfb4db56de847f081bd093a8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2858d995fee359f9751c0424d03c2034"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a2858d995fee359f9751c0424d03c2034">createFinalizingBufferizePass</a> ()</td></tr>
<tr class="memdesc:a2858d995fee359f9751c0424d03c2034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations.  <a href="#a2858d995fee359f9751c0424d03c2034">More...</a><br /></td></tr>
<tr class="separator:a2858d995fee359f9751c0424d03c2034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd135f127fc250fb96fd3817f98ab9d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#aadd135f127fc250fb96fd3817f98ab9d">createPromoteBuffersToStackPass</a> (<a class="el" href="classunsigned.html">unsigned</a> maxAllocSizeInBytes=1024, <a class="el" href="classunsigned.html">unsigned</a> maxRankOfAllocatedMemRef=1)</td></tr>
<tr class="memdesc:aadd135f127fc250fb96fd3817f98ab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="#aadd135f127fc250fb96fd3817f98ab9d">More...</a><br /></td></tr>
<tr class="separator:aadd135f127fc250fb96fd3817f98ab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html#a62a9fdbeb428d3911ee0fbfbc3854283">createPromoteBuffersToStackPass</a> (std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; isSmallAlloc)</td></tr>
<tr class="memdesc:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that promotes heap-based allocations to stack-based ones.  <a href="#a62a9fdbeb428d3911ee0fbfbc3854283">More...</a><br /></td></tr>
<tr class="separator:a62a9fdbeb428d3911ee0fbfbc3854283"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9143a6cd46c797fef5768cfff4b64ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9143a6cd46c797fef5768cfff4b64ac2">&#9670;&nbsp;</a></span>PostAnalysisStepFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#a9143a6cd46c797fef5768cfff4b64ac2">mlir::bufferization::PostAnalysisStepFn</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;, <a class="el" href="classmlir_1_1bufferization_1_1BufferizationAliasInfo.html">BufferizationAliasInfo</a> &amp;, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PostAnalysisStepFns can be registered with <code><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html" title="Options for ComprehensiveBufferize. ">BufferizationOptions</a></code> and are executed after the analysis, but before bufferization. </p>
<p>They can be used to implement custom dialect-specific optimizations. They may modify the IR, but must keep <code>aliasInfo</code> consistent. Newly created operations and operations that should be re-analyzed must be added to <code>newOps</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8h_source.html#l00030">30</a> of file <a class="el" href="OneShotAnalysis_8h_source.html">OneShotAnalysis.h</a>.</p>

</div>
</div>
<a id="aa69770dbd42d4a1a08c95e6824e30db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69770dbd42d4a1a08c95e6824e30db0">&#9670;&nbsp;</a></span>PostAnalysisStepList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1bufferization.html#aa69770dbd42d4a1a08c95e6824e30db0">mlir::bufferization::PostAnalysisStepList</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="namespacemlir_1_1bufferization.html#a9143a6cd46c797fef5768cfff4b64ac2">PostAnalysisStepFn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8h_source.html#l00032">32</a> of file <a class="el" href="OneShotAnalysis_8h_source.html">OneShotAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="afbf6d54f9e3c10b9003b66b6224b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf6d54f9e3c10b9003b66b6224b28bf">&#9670;&nbsp;</a></span>BufferRelation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1bufferization.html#afbf6d54f9e3c10b9003b66b6224b28bf">mlir::bufferization::BufferRelation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify fine-grain relationship between buffers to enable more analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfa6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afbf6d54f9e3c10b9003b66b6224b28bfaafd102579f64c98e96d92a7424130605"></a>Equivalent&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00232">232</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5af60e4c732407b8ec9b0bee7f33079a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af60e4c732407b8ec9b0bee7f33079a">&#9670;&nbsp;</a></span>analyzeOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::analyzeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1AnalysisBufferizationState.html">AnalysisBufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analyze <code>op</code> and its nested ops. </p>
<p>Bufferization decisions are stored in <code>state</code>. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l00749">749</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l00669">annotateOpsWithBufferizationMarkers()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00704">assertDestinationPassingStyle()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00640">checkAliasInfoConsistency()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00606">equivalenceAnalysis()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="OneShotAnalysis_8h_source.html#l00148">mlir::bufferization::AnalysisBufferizationState::getAliasInfo()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00352">mlir::bufferization::BufferizationState::getOptions()</a>, <a class="el" href="OneShotAnalysis_8cpp_source.html#l00555">inPlaceAnalysis()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8h_source.html#l00148">mlir::bufferization::AnalysisBufferizationState::getAliasInfo()</a>, <a class="el" href="ModuleBufferization_8cpp_source.html#l00994">mlir::linalg::comprehensive_bufferize::runModuleBufferize()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00788">runOneShotBufferize()</a>.</p>

</div>
</div>
<a id="a06ffab001193a2ce1acc4427e25ae2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06ffab001193a2ce1acc4427e25ae2cc">&#9670;&nbsp;</a></span>bufferizeOp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Whether buffer copies are needed or not is queried from <code>state</code>.</p>
<p>Note: If <code>allowUnknownOps</code> is set to false, bufferization fails when an unknown op (that does not implement <code>BufferizableOpInterface</code>) is found. No to_tensor/to_memref ops are inserted in that case.</p>
<p>Note: The layout map chosen to bufferize is the most dynamic canonical strided layout of the proper rank. This ensures compatibility with expected layouts after transformations. Combinations of memref.cast + canonicalization are responsible for clean ups. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00205">205</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00367">mlir::applyPatternsAndFoldGreedily()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00173">checkBufferizationResult()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="Operation_8h_source.html#l00099">mlir::Operation::getContext()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00352">mlir::bufferization::BufferizationState::getOptions()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00282">isInPlace()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, and <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00251">populateBufferizationPattern()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00245">bufferizeOp()</a>, <a class="el" href="ModuleBufferization_8cpp_source.html#l00994">mlir::linalg::comprehensive_bufferize::runModuleBufferize()</a>, and <a class="el" href="OneShotAnalysis_8cpp_source.html#l00788">runOneShotBufferize()</a>.</p>

</div>
</div>
<a id="ac2eb90676228266b5cf038ee3565363f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eb90676228266b5cf038ee3565363f">&#9670;&nbsp;</a></span>bufferizeOp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::bufferizeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bufferize <code>op</code> and its nested ops that implement <code>BufferizableOpInterface</code>. </p>
<p>Buffers are duplicated and copied before any tensor use that bufferizes to a memory write.</p>
<p>Note: This function bufferizes ops without utilizing analysis results. It can be used to implement partial bufferization passes. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00245">245</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00205">bufferizeOp()</a>.</p>

</div>
</div>
<a id="ab906909c95ea6668aeec6bc2901e6936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab906909c95ea6668aeec6bc2901e6936">&#9670;&nbsp;</a></span>createAlloc() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::createAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dynShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memref allocation with the given type and dynamic extents. </p>
<p>Create a memref allocation with the given type and dynamic extents. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00465">465</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8h_source.html#l00172">mlir::bufferization::BufferizationOptions::allocationFn</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00206">mlir::bufferization::BufferizationOptions::bufferAlignment</a>, <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, and <a class="el" href="Builders_8cpp_source.html#l00099">mlir::Builder::getI64IntegerAttr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00428">createAlloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00236">mlir::bufferization::BufferizationState::getBuffer()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a6422d348bb770ae024a1571495a7587a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6422d348bb770ae024a1571495a7587a">&#9670;&nbsp;</a></span>createAlloc() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::createAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dynShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocMemref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memref allocation with the given type and dynamic extents. </p>
<p>Create a memref allocation with the given type and dynamic extents.</p>
<p>If <code>createDealloc</code>, a deallocation op is inserted at the point where the allocation goes out of scope.</p>
<p>May also deallocate the memref again. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00481">481</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00465">createAlloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00502">createDealloc()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="ad45a2e4367318cf238e367aec24953cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45a2e4367318cf238e367aec24953cb">&#9670;&nbsp;</a></span>createAlloc() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::bufferization::createAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>shapedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deallocMemref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memref allocation for the given shaped value. </p>
<p>Create an AllocOp/DeallocOp pair, where the AllocOp is after <code>shapedValue.getDefiningOp</code> (or at the top of the block in case of a bbArg) and the DeallocOp is at the end of the block.</p>
<p>This function may perform additional optimizations such as buffer allocation hoisting. If <code>createDealloc</code>, a deallocation op is inserted at the point where the allocation goes out of scope.</p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00428">428</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00465">createAlloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00502">createDealloc()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00380">getAllocationTypeAndShape()</a>, <a class="el" href="Value_8h_source.html#l00117">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, and <a class="el" href="Builders_8h_source.html#l00329">mlir::OpBuilder::setInsertionPoint()</a>.</p>

</div>
</div>
<a id="adbadbbffeae2eddfac65c53b2f1cadba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadbbffeae2eddfac65c53b2f1cadba">&#9670;&nbsp;</a></span>createBufferDeallocationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferDeallocationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the BufferDeallocation pass to free all allocated buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocation_8cpp_source.html#l00681">681</a> of file <a class="el" href="BufferDeallocation_8cpp_source.html">BufferDeallocation.cpp</a>.</p>

</div>
</div>
<a id="a4b99b019001e22f13cbb9adaf483febe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b99b019001e22f13cbb9adaf483febe">&#9670;&nbsp;</a></span>createBufferHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards to reduce the number of required copies that are inserted during the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00420">420</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a94f24bfd4dabfbaa35cb099c0cc78480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f24bfd4dabfbaa35cb099c0cc78480">&#9670;&nbsp;</a></span>createBufferLoopHoistingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferLoopHoistingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that moves allocations upwards out of loops. </p>
<p>This avoids reallocations inside of loops. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00424">424</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="abdbbddbfb4db56de847f081bd093a8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbbddbfb4db56de847f081bd093a8fc">&#9670;&nbsp;</a></span>createBufferResultsToOutParamsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createBufferResultsToOutParamsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts memref function results to out-params. </p>

<p class="definition">Definition at line <a class="el" href="BufferResultsToOutParams_8cpp_source.html#l00145">145</a> of file <a class="el" href="BufferResultsToOutParams_8cpp_source.html">BufferResultsToOutParams.cpp</a>.</p>

</div>
</div>
<a id="ad9e102c19d8782b9502708be05b74311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e102c19d8782b9502708be05b74311">&#9670;&nbsp;</a></span>createDealloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::createDealloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>allocatedBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memref deallocation. </p>
<p>Create a memref deallocation.</p>
<p>The given memref buffer must have been allocated using <code>createAlloc</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00502">502</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00173">mlir::bufferization::BufferizationOptions::deallocationFn</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00428">createAlloc()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a2858d995fee359f9751c0424d03c2034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2858d995fee359f9751c0424d03c2034">&#9670;&nbsp;</a></span>createFinalizingBufferizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; FuncOp &gt; &gt; mlir::bufferization::createFinalizingBufferizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that finalizes a partial bufferization by removing remaining bufferization.to_tensor and bufferization.to_memref operations. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00131">131</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SparseTensorPipelines_8cpp_source.html#l00029">mlir::sparse_tensor::buildSparseCompiler()</a>.</p>

</div>
</div>
<a id="a8945451b63f8606fffb80adc08ab2cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8945451b63f8606fffb80adc08ab2cbe">&#9670;&nbsp;</a></span>createMemCpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::createMemCpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a memcpy between two given buffers. </p>
<p>Create a memory copy between two memref buffers. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00513">513</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00174">mlir::bufferization::BufferizationOptions::memCpyFn</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00236">mlir::bufferization::BufferizationState::getBuffer()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="aadd135f127fc250fb96fd3817f98ab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd135f127fc250fb96fd3817f98ab9d">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxAllocSizeInBytes</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>maxRankOfAllocatedMemRef</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller than the provided size are promoted. Dynamic shaped buffers are promoted up to the given rank. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00428">428</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="a62a9fdbeb428d3911ee0fbfbc3854283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a9fdbeb428d3911ee0fbfbc3854283">&#9670;&nbsp;</a></span>createPromoteBuffersToStackPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::bufferization::createPromoteBuffersToStackPass </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>isSmallAlloc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that promotes heap-based allocations to stack-based ones. </p>
<p>Only buffers smaller with <code>isSmallAlloc(alloc) == true</code> are promoted. </p>

<p class="definition">Definition at line <a class="el" href="BufferOptimizations_8cpp_source.html#l00434">434</a> of file <a class="el" href="BufferOptimizations_8cpp_source.html">BufferOptimizations.cpp</a>.</p>

</div>
</div>
<a id="abee671301347ef45d17b909d3ae286aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee671301347ef45d17b909d3ae286aa">&#9670;&nbsp;</a></span>getContiguousMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::bufferization::getContiguousMemRefType </td>
          <td>(</td>
          <td class="paramtype">ShapedType&#160;</td>
          <td class="paramname"><em>shapedType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a contiguous <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> (i.e. </p>
<p>with canonical/empty layout map) with the same shape as <code>shapedType</code> and specified <code>addressSpace</code>. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00534">534</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00380">getAllocationTypeAndShape()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="aaaa111ae7f728e7e3a776a2a67a177fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa111ae7f728e7e3a776a2a67a177fb">&#9670;&nbsp;</a></span>getGlobalFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FailureOr.html">FailureOr</a>&lt; memref::GlobalOp &gt; mlir::bufferization::getGlobalFor </td>
          <td>(</td>
          <td class="paramtype">arith::ConstantOp&#160;</td>
          <td class="paramname"><em>constantOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferUtils_8cpp_source.html#l00148">148</a> of file <a class="el" href="BufferUtils_8cpp_source.html">BufferUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l02947">mlir::TypeConverter::convertType()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00172">mlir::Region::getOps()</a>, and <a class="el" href="Operation_8h_source.html#l00428">mlir::Operation::getRegion()</a>.</p>

</div>
</div>
<a id="a7ba55edae716ab18fa6fe171c8ea804d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba55edae716ab18fa6fe171c8ea804d">&#9670;&nbsp;</a></span>getMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> mlir::bufferization::getMemRefType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a>&#160;</td>
          <td class="paramname"><em>tensorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefLayoutAttrInterface&#160;</td>
          <td class="paramname"><em>layout</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a <a class="el" href="namespacemlir_1_1MemRefType.html">MemRefType</a> to which the <code>tensorType</code> can be bufferized in a composable fashion. </p>
<p>The layout must be the most dynamic possible and canonicalize away once bufferization is finished. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00541">541</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Types_8h_source.html#l00250">mlir::Type::cast()</a>, <a class="el" href="IR_2Types_8h_source.html#l00244">mlir::Type::dyn_cast()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00195">mlir::bufferization::BufferizationOptions::fullyDynamicLayoutMaps</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00862">mlir::makeStridedLinearLayoutMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l02898">foldTransferInBoundsAttribute()</a>, <a class="el" href="ModuleBufferization_8cpp_source.html#l00332">getBufferizedFunctionType()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00215">lookupBuffer()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01532">CollapseShapeOpMemRefCastFolder::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02634">CanonicalizeSingleResultAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="MemRefOps_8cpp_source.html#l01053">parseGlobalMemrefOpTypeAndInitialValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01939">mlir::replaceForOpWithNewYields()</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02291">verifyMemoryOpIndexing()</a>, <a class="el" href="AMXDialect_8cpp_source.html#l00043">verifyMultShape()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l03511">verifyVectorMemoryOp()</a>.</p>

</div>
</div>
<a id="ac36c97b27b691ad7fcee01d70ca143a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36c97b27b691ad7fcee01d70ca143a9">&#9670;&nbsp;</a></span>getPartialBufferizationOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1bufferization_1_1BufferizationOptions.html">BufferizationOptions</a> mlir::bufferization::getPartialBufferizationOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00256">256</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferizableOpInterface_8h_source.html#l00178">mlir::bufferization::BufferizationOptions::allowReturnMemref</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00183">mlir::bufferization::BufferizationOptions::allowUnknownOps</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00187">mlir::bufferization::BufferizationOptions::createDeallocs</a>, <a class="el" href="BufferizableOpInterface_8h_source.html#l00195">mlir::bufferization::BufferizationOptions::fullyDynamicLayoutMaps</a>, and <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>.</p>

</div>
</div>
<a id="aa24e592182e0b88ede8e85dbc3dcac5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24e592182e0b88ede8e85dbc3dcac5e">&#9670;&nbsp;</a></span>isFunctionArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::bufferization::isFunctionArgument </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given value is a <a class="el" href="classmlir_1_1BlockArgument.html" title="This class represents an argument of a Block. ">BlockArgument</a> of a FuncOp. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00527">527</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00099">mlir::Value::dyn_cast()</a>.</p>

</div>
</div>
<a id="aa1e0264f03d3674db311e3f98d9dc468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e0264f03d3674db311e3f98d9dc468">&#9670;&nbsp;</a></span>populateBufferizationPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::populateBufferizationPattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1BufferizationState.html">BufferizationState</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the pattern set with a pattern that bufferizes ops that implement <code>BufferizableOpInterface</code>. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00251">251</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00930">mlir::RewritePatternSet::add()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00906">mlir::RewritePatternSet::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00205">bufferizeOp()</a>.</p>

</div>
</div>
<a id="a6223871e93de2dbc611e8e54c5e4fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6223871e93de2dbc611e8e54c5e4fb3b">&#9670;&nbsp;</a></span>populateBufferizeMaterializationLegality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::populateBufferizeMaterializationLegality </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks ops used by bufferization for type conversion materializations as "legal" in the given <a class="el" href="classmlir_1_1ConversionTarget.html" title="This class describes a specific conversion target. ">ConversionTarget</a>. </p>
<p>This function should be called by all bufferization passes using <a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html" title="A helper type converter class that automatically populates the relevant materializations and type con...">BufferizeTypeConverter</a> so that materializations work properly. One exception is bufferization passes doing "full" conversions, where it can be desirable for even the materializations to remain illegal so that they are eliminated, such as via the patterns in populateEliminateBufferizeMaterializationsPatterns. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00054">54</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00693">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00403">mlir::OpConversionPattern&lt; SourceOp &gt;::OpConversionPattern()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01513">mlir::ConversionPatternRewriter::replaceOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

</div>
</div>
<a id="a22345dcd836dbc3216a89bbd4ce26821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22345dcd836dbc3216a89bbd4ce26821">&#9670;&nbsp;</a></span>populateEliminateBufferizeMaterializationsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::populateEliminateBufferizeMaterializationsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1BufferizeTypeConverter.html">BufferizeTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns to eliminate bufferize materializations. </p>
<p>In particular, these are the tensor_load/buffer_cast ops. </p>

<p class="definition">Definition at line <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00091">91</a> of file <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html">Bufferize.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00930">mlir::RewritePatternSet::add()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03284">mlir::applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00906">mlir::RewritePatternSet::getContext()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03003">mlir::TypeConverter::isLegal()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00792">mlir::ConversionTarget::markUnknownOpDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="a05561ae5b9cceea1c45832340484ad6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05561ae5b9cceea1c45832340484ad6b">&#9670;&nbsp;</a></span>replaceOpWithBufferizedValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::bufferization::replaceOpWithBufferizedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with replacement values. </p>
<p>The op is deleted. Tensor OpResults must be replaced with memref values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00293">293</a> of file <a class="el" href="BufferizableOpInterface_8cpp_source.html">BufferizableOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="Value_8cpp_source.html#l00026">mlir::Value::getLoc()</a>, <a class="el" href="Operation_8h_source.html#l00272">mlir::Operation::getNumResults()</a>, <a class="el" href="Operation_8h_source.html#l00288">mlir::Operation::getOpResults()</a>, <a class="el" href="Value_8h_source.html#l00117">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8h_source.html#l00234">mlir::Type::isa()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00245">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00343">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ModuleBufferization_8cpp_source.html#l00775">mlir::linalg::comprehensive_bufferize::std_ext::CallOpInterface::bufferize()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">replaceOpWithNewBufferizedOp()</a>.</p>

</div>
</div>
<a id="a91366abfb8d491ea5701260487518959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91366abfb8d491ea5701260487518959">&#9670;&nbsp;</a></span>replaceOpWithNewBufferizedOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpTy mlir::bufferization::replaceOpWithNewBufferizedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace an op with a new op. </p>
<p>The new op must have the same number of results as the replaced op. The new op may not return any tensor values. </p>

<p class="definition">Definition at line <a class="el" href="BufferizableOpInterface_8h_source.html#l00396">396</a> of file <a class="el" href="BufferizableOpInterface_8h_source.html">BufferizableOpInterface.h</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00430">mlir::OpBuilder::create()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00465">createAlloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00502">createDealloc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00513">createMemCpy()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00534">getContiguousMemRefType()</a>, <a class="el" href="Operation_8h_source.html#l00106">mlir::Operation::getLoc()</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00541">getMemRefType()</a>, <a class="el" href="Operation_8h_source.html#l00283">mlir::Operation::getResults()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00083">options</a>, <a class="el" href="BufferizableOpInterface_8cpp_source.html#l00293">replaceOpWithBufferizedValues()</a>, and <a class="el" href="BufferizableOpInterface_8h_source.html#l00058">mlir::bufferization::BufferizationOptions::OpFilterEntry::type</a>.</p>

</div>
</div>
<a id="ac312904e236e76916c7e8c1d1b989a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac312904e236e76916c7e8c1d1b989a1b">&#9670;&nbsp;</a></span>runOneShotBufferize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::bufferization::runOneShotBufferize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="structmlir_1_1bufferization_1_1AnalysisBufferizationOptions.html">AnalysisBufferizationOptions</a> &gt;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run One-Shot Bufferize on the given op: Analysis + Bufferization. </p>

<p class="definition">Definition at line <a class="el" href="OneShotAnalysis_8cpp_source.html#l00788">788</a> of file <a class="el" href="OneShotAnalysis_8cpp_source.html">OneShotAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="OneShotAnalysis_8cpp_source.html#l00749">analyzeOp()</a>, <a class="el" href="Bufferization_2Transforms_2Bufferize_8cpp_source.html#l00205">bufferizeOp()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="OneShotAnalysis_8h_source.html#l00148">mlir::bufferization::AnalysisBufferizationState::getAliasInfo()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Feb 18 2022 04:35:01 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
